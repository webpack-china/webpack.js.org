---
title: To v2 or v3 from v1
sort: 3
contributors:
  - sokra
  - jhnns
  - grgur
  - domfarolino
  - johnnyreilly
  - jouni-kantola
  - frederikprijck
  - chrisVillanueva
  - bebraw
  - howdy39
  - selbekk
  - ndelangen
  - EugeneHlushko
  - byzyk
---

下面的部分描述了从 webpack 1 到 webpack 2 的主要变化。

T> 注意，webpack 2 和 3 之间的变化很少，所以升级迁移起来不会太糟。如果遇到问题，详情请参阅 [the changelog](https://github.com/webpack/webpack/releases) 。


## `resolve.root`, `resolve.fallback`, `resolve.modulesDirectories`

使用一个`resolve.modules`配置替换了下面这些配置项。更多用法请参阅 [resolving](/configuration/resolve)。

``` diff
  resolve: {
-   root: path.join(__dirname, "src")
+   modules: [
+     path.join(__dirname, "src"),
+     "node_modules"
+   ]
  }
```


## `resolve.extensions`

这个配置在使用时不再需要传入一个空字符串，该配置已迁移至  `resolve.enforceExtension` 。更多用法请参阅[resolving](/configuration/resolve)。


## `resolve.*`

有一些 API 发生了改变。因为不常用在这里没有详细列出。更多细节请参阅[resolving](/configuration/resolve)。


## `module.loaders` 升级为 `module.rules`

旧的 loader 配置被一个更强大的规则系统取代，该系统除了允许配置 loader 还支持其他更多配置。
考虑到兼容性，系统仍然支持解析旧的配置项，也可以使用旧的配置  `module.loaders` 。
新的配置命名很容易理解，这也不失为一个好的理由升级使用新的配置 `module.rules` 。

``` diff
  module: {
-   loaders: [
+   rules: [
      {
        test: /\.css$/,
-       loaders: [
-         "style-loader",
-         "css-loader?modules=true"
+       use: [
+         {
+           loader: "style-loader"
+         },
+         {
+           loader: "css-loader",
+           options: {
+             modules: true
+           }
+         }
        ]
      },
      {
        test: /\.jsx$/,
        loader: "babel-loader", // 在这里不要使用 'use' 
        options: {
          // ...
        }
      }
    ]
  }
```


## 链式 loaders

和 webpack 1 一样，loaders 支持将执行结果从一个 loader 传递给 下一个 loader 的串行链式调用。
使用[rule.use](/configuration/module/#ruleuse) 配置项， `use` 支持配置 loaders 数组。 
在 webpack 1 中，多个 loaders 的串联都是用 `!` 。只有在`module.loaders` 中才支持这种写法。

``` diff
  module: {
-   loaders: [{
+   rules: [{
      test: /\.less$/,
-     loader: "style-loader!css-loader!less-loader"
+     use: [
+       "style-loader",
+       "css-loader",
+       "less-loader"
+     ]
    }]
  }
```


## 已移除 `-loader` 模块名称自动扩展

在引用 loaders 时，不能再使用 `-loader` 自动扩展：

``` diff
  module: {
    rules: [
      {
        use: [
-         "style",
+         "style-loader",
-         "css",
+         "css-loader",
-         "less",
+         "less-loader",
        ]
      }
    ]
  }
```

你可以通过 `resolveLoader.moduleExtensions` 继续使用这种低版本的配置形式，但是官方不推荐。

``` diff
+ resolveLoader: {
+   moduleExtensions: ["-loader"]
+ }
```

具体原因请参阅 [#2986](https://github.com/webpack/webpack/issues/2986) 。


## 不再需要强制引入 `json-loader` 

当用户没有配置解析 JSON 文件的配置项时，webpack 会自动使用[`json-loader`](https://github.com/webpack-contrib/json-loader) 
解析 JSON 文件。

``` diff
  module: {
    rules: [
-     {
-       test: /\.json/,
-       loader: "json-loader"
-     }
    ]
  }
```

[我们决定这样做](https://github.com/webpack/webpack/issues/3363) 
是为了消除 webpack、nodejs、browserify 之间的环境差异。


## Loaders in configuration resolve relative to context

In __webpack 1__, configured loaders resolve relative to the matched file. However, in __webpack 2__, configured loaders resolve relative to the `context` option.

This solves some problems with duplicate modules caused by loaders when using `npm link` or referencing modules outside of the `context`.

You may remove some hacks to work around this:

``` diff
  module: {
    rules: [
      {
        // ...
-       loader: require.resolve("my-loader")
+       loader: "my-loader"
      }
    ]
  },
  resolveLoader: {
-   root: path.resolve(__dirname, "node_modules")
  }
```


## 移除了 `module.preLoaders` 和 `module.postLoaders` ：

``` diff
  module: {
-   preLoaders: [
+   rules: [
      {
        test: /\.js$/,
+       enforce: "pre",
        loader: "eslint-loader"
      }
    ]
  }
```


## `UglifyJsPlugin` sourceMap

 `UglifyJsPlugin` 配置中的 `sourceMap` 选项默认设置为 false 替代之前的默认值 `true` 。这就意味着如果你想要在压缩过的代码中使用 source maps 或者 想要看到正确的行号，你需要在 `UglifyJsPlugin` 配置中设置 `sourceMap: true` 。

``` diff
  devtool: "source-map",
  plugins: [
    new UglifyJsPlugin({
+     sourceMap: true
    })
  ]
```


## `UglifyJsPlugin` 警告提示

 `UglifyJsPlugin` 配置中 `compress.warnings` 选项默认设置为 `false` 替代之前的默认值 `true` 。
 这就意味着如果你想看到 uglifyjs 静态提示，你需要设置 `compress.warnings` 为 `true` 。

``` diff
  devtool: "source-map",
  plugins: [
    new UglifyJsPlugin({
+     compress: {
+       warnings: true
+     }
    })
  ]
```


## `UglifyJsPlugin` 压缩优化 loaders

`UglifyJsPlugin` 不再压缩优化代码。长期而言需要设置 loader 的配置项 `minimize: true` 。其他相关配置项请参阅 loader 配置文档。

在 webpack 3 或者之后的版本中，将会移除 loader 压缩优化的代码。

为了兼容低版本的 loaders，可以使用插件将 loaders 转换为最小化模式。

``` diff
  plugins: [
+   new webpack.LoaderOptionsPlugin({
+     minimize: true
+   })
  ]
```


## 已经移除 `DedupePlugin` 

已经不再需要 `webpack.optimize.DedupePlugin` 。请在你的配置中移除这个配置项。


## `BannerPlugin` - 突破性改变

`BannerPlugin` 不再需要配置两个参数，直接使用一个配置项对象。

``` diff
  plugins: [
-    new webpack.BannerPlugin('Banner', {raw: true, entryOnly: true});
+    new webpack.BannerPlugin({banner: 'Banner', raw: true, entryOnly: true});
  ]
```


## `OccurrenceOrderPlugin` 默认生效

 `OccurrenceOrderPlugin` 配置现在默认生效并且已经重新更正过配置名(在webpack 1 中是 `OccurenceOrderPlugin`)。
因此请确保在你的配置项中移除这个插件的调用：

``` diff
  plugins: [
    // webpack 1
-   new webpack.optimize.OccurenceOrderPlugin()
    // webpack 2
-   new webpack.optimize.OccurrenceOrderPlugin()
  ]
```


## `ExtractTextWebpackPlugin` - 突破性改变

在 webpack 2 中需要引入 [ExtractTextPlugin](https://github.com/webpack-contrib/extract-text-webpack-plugin) 的版本 2 。

`npm install --save-dev extract-text-webpack-plugin`

这个插件配置的改变主要是语法方面。

### `ExtractTextPlugin.extract`

```diff
module: {
  rules: [
    {
      test: /.css$/,
-      loader: ExtractTextPlugin.extract("style-loader", "css-loader", { publicPath: "/dist" })
+      use: ExtractTextPlugin.extract({
+        fallback: "style-loader",
+        use: "css-loader",
+        publicPath: "/dist"
+      })
    }
  ]
}
```


### `new ExtractTextPlugin({options})`

```diff
plugins: [
-  new ExtractTextPlugin("bundle.css", { allChunks: true, disable: false })
+  new ExtractTextPlugin({
+    filename: "bundle.css",
+    disable: false,
+    allChunks: true
+  })
]
```


## 全量动态的 requires 引入默认失败

现在只有一个表达式的依赖(例如： `require(expr)`) 将会创建一个空的上下文，代替一个完全目录的上下文。

像这样的代码在 es2015 语法的模块里无法解析执行，所以需要重构。如果还是不行，你可以使用 `ContextReplacementPlugin` 提示编译器以正确的方式解析。

?> 动态依赖文章的链接占位

### 在脚手架和配置中使用自定义参数

如果你不再像下面这样在 CLI 中传递自定义参数：

`webpack --custom-stuff`

```js
// webpack.config.js
var customStuff = process.argv.indexOf('--custom-stuff') >= 0;
/* ... */
module.exports = config;
```

你可能注意到已经不允许自定义传递参数了。CLI 现在更加严格了。

相反会有接口支持传递参数到配置中。应该使用这种接口。未来的工具可能就依赖这个接口传参。

`webpack --env.customStuff`

```js
module.exports = function(env) {
  var customStuff = env.customStuff;
  /* ... */
  return config;
};
```

请参阅 [CLI](/api/cli)。


## `require.ensure` 和 AMD `require` 都是异步的

这些方法现在都已经是异步请求了，代替了chunk下载完成之后同步调用回调的方式。

__`require.ensure` 现在依赖原生的 `Promise`s 。如果在一个不支持的环境中使用 `require.ensure` ，需要 polyfill.__ 支持。


## 在 `options` 中配置 Loader 

在 `webpack.config.js` 中，你不再需要通过自定义属性配置 loader 。必须在 `options` 中配置 loader 。下面 `ts` 相关的配置已经在 webpack 2 中不再起作用。

```js
module.exports = {
  //...
  module: {
    rules: [{
      test: /\.tsx?$/,
      loader: 'ts-loader'
    }]
  },
  // 在 webpack 2 中不起作用
  ts: { transpileOnly: false }
};
```


### 什么是 `options` ？

好问题。严格的来说这是两种可能性。都是配置 webpack loader 的方式。一般来说， `options` 被称为 `query` ，是紧跟在 loader 后面的字符串。像一个查询字符串但其实有 [更强大的作用](https://github.com/webpack/loader-utils#parsequery):

```js
module.exports = {
  //...
  module: {
    rules: [{
      test: /\.tsx?$/,
      loader: 'ts-loader?' + JSON.stringify({ transpileOnly: false })
    }]
  }
};
```

但是它也可以是一个在 loader 之外单独指定的对象：

```js
module.exports = {
  //...
  module: {
    rules: [{
      test: /\.tsx?$/,
      loader: 'ts-loader',
      options:  { transpileOnly: false }
    }]
  }
};
```


## `LoaderOptionsPlugin` 上下文

有一些 loaders 需要从配置中获取上下文信息。长期来看，这些信息需要通过 loader 配置项传入。更多相关配置项请参阅 loader 文档。

为了兼容低版本 loaders ，这些信息也可以通过插件传入：

``` diff
  plugins: [
+   new webpack.LoaderOptionsPlugin({
+     options: {
+       context: __dirname
+     }
+   })
  ]
```


## `debug`

在 webpack 1 中 `debug` 选项可以设置 loaders 为 debug 模式。长期来看，这些信息需要通过 loader 配置项传入。更多相关配置项请参阅 loader 文档。

在 webpack 3 或者 之后的版本中，loaders 的 debug 模式将会被移除。

为了兼容低版本 loaders ，可以通过插件将 loaders 切换到 debug 模式：

``` diff
- debug: true,
  plugins: [
+   new webpack.LoaderOptionsPlugin({
+     debug: true
+   })
  ]
```


## Code Splitting with ES2015

在 webpack 1 中，你可以在应用中使用 [`require.ensure()`](/api/module-methods/#requireensure) 来懒加载代码段。

```javascript
require.ensure([], function(require) {
  var foo = require('./module');
});
```

es2015 loader 特别定义了 [`import()`](/api/module-methods/#import-1) 作为运行时动态加载 es2015 模块的方法。 webpack 将 `import()` 作为一个代码拆分的点，并且将这些必需的模块放在一个单独的段中。 `import()` 以模块名称作为参数、返回一个 Promise 。

```js
function onClick() {
  import('./module').then(module => {
    return module.default;
  }).catch(err => {
    console.log('Chunk loading failed');
  });
}
```

好消息：因为是基于 `Promise` ，我们现在可以处理加载代码段失败的情况。


## 动态表达式

传递部分表达式给 `import()` 也是有可能的。跟在 CommonJS 中处理表达式的方式相似(webpack 利用所有可能的文件创建一个 [context](/plugins/context-replacement-plugin/))。

`import()` 为每一个可能的模块创建一个单独的代码段。

```js
function route(path, query) {
  return import(`./routes/${path}/route`)
    .then(route => new route.Route(query));
}
// 为每一个可能的路由创建单独的代码段
```


## 在 AMD 和 CommonJS 中混合使用 ES2015

在 AMD 和 CommonJS 中，你可以自由的混合使用三个模块类型（即便是在相同的文件里）。在这种情况下，webpack 面对 babel 和 node-eps 表现一致：

```javascript
// CommonJS 中引入 ES2015 模块
var book = require('./book');

book.currentPage;
book.readPage();
book.default === 'This is a book';
```

```javascript
// ES2015 模块中引入 CommonJS
import fs from 'fs'; // module.exports map to default
import { readFileSync } from 'fs'; // named exports are read from returned object+

typeof fs.readFileSync === 'function';
typeof readFileSync === 'function';
```

有一个重要的点要注意到，你需要通知 Babel 不要解析那些模块符号，这样 webpack 才能继续工作解析下去。你可以在你的`.babelrc` 或者 `babel-loader` 文件中配置下面这些配置项：

__.babelrc__

```json
{
  "presets": [
    ["es2015", { "modules": false }]
  ]
}
```


## 提示

不需要改变什么，但是要抓住机会。

### 模版字符串

webpack 现在支持在表达式中使用摸板字符串。这就意味着你可以在 webpack 构造函数中着手使用：

``` diff
- require("./templates/" + name);
+ require(`./templates/${name}`);
```


### Configuration Promise

webpack 现在支持从配置文件中返回一个 `Promise` 。这就说明在配置文件中可以实现异步解析。

__webpack.config.js__

```js
module.exports = function() {
  return fetchLangs().then(lang => ({
    entry: '...',
    // ...
    plugins: [
      new DefinePlugin({ LANGUAGE: lang })
    ]
  }));
};
```


### Advanced loader matching

webpack 现在支持更多形式去匹配 loaders。

```js
module.exports = {
  //...
  module: {
    rules: [
      {
        resource: /filename/, // matches "/path/filename.js"
        resourceQuery: /^\?querystring$/, // matches "?querystring"
        issuer: /filename/, // matches "/path/something.js" if requested from "/path/filename.js"
      }
    ]
  }
};
```


### 更多的 CLI 选项

你可以使用更多的新 CLI 选项：

`--define process.env.NODE_ENV="production"` 请参阅 [`DefinePlugin`](/plugins/define-plugin/).

`--display-depth` 可以获取每个模块距离入口的距离。

`--display-used-exports` 可以获取一个模块所有的导出信息。

`--display-max-modules` 可以设置导出的模块数量（默认是15个）。

`-p` 也可以在`"production"` 环境定义 `process.env.NODE_ENV` 。


## Loader 改变

改变仅仅和 loader 的作者相关。


### Cacheable

Loaders 现在默认支持可缓存。不支持缓存的 Loaders 必须设置为false。

``` diff
  // Cacheable loader
  module.exports = function(source) {
-   this.cacheable();
    return source;
  }
```

``` diff
  // Not cacheable loader
  module.exports = function(source) {
+   this.cacheable(false);
    return source;
  }
```


### 复杂选项

__webpack 1__ 仅仅支持 loaders的 `JSON.stringify`-able 选项。

__webpack 2__ 现在支持任意 JS 对象作为 loader 选项。

在webpack [2.2.1](https://github.com/webpack/webpack/releases/tag/v2.2.1) 版本之前(例如从 2.0.0 到 2.2.0), 使用复杂选项的话，必须在`options` 对象中使用 `ident` 来确保其他 loaders 可以引用。   __在 2.2.1 版本中已经移除__ 并且现在的配置已经不再需要使用 `ident` 。

```diff
{
  test: /\.ext/
  use: {
    loader: '...',
    options: {
-     ident: 'id',
      fn: () => require('./foo.js')
    }
  }
}
```
